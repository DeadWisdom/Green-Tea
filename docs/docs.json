[{"short": "Tea", "name": "Tea", "text": "<p>Complex UI framework based on jQuery. </p>\n<p>Copyright (c) 2010 Brantley Harris. All rights reserved. </p>\n", "important": false, "sig": "", "type": "class", "children": [{"short": "Class", "name": "Tea.Class", "text": "<p>Returns a new Class function with a defined prototype and options. </p>\n<p>Example: </p>\n<div class='code'>App.Greeter&nbsp;=&nbsp;Tea.Class('App.Greeter',&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;options:&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;recipient&nbsp;:&nbsp;\"world\"<br/>&nbsp;&nbsp;&nbsp;&nbsp;},<br/>&nbsp;&nbsp;&nbsp;&nbsp;greet&nbsp;:&nbsp;function()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;alert(\"Hello&nbsp;\"&nbsp;+&nbsp;this.options.recipient&nbsp;+&nbsp;\"!\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>})<br/><br/>&gt;&gt;&gt;&nbsp;var&nbsp;greeter&nbsp;=&nbsp;new&nbsp;App.Greeter();<br/>&gt;&gt;&gt;&nbsp;greeter.greet();<br/>Hello&nbsp;world!<br/><br/>&gt;&gt;&gt;&nbsp;var&nbsp;greeter&nbsp;=&nbsp;new&nbsp;App.Greeter({recipient:&nbsp;'javascripter'});<br/>&gt;&gt;&gt;&nbsp;greeter.greet();<br/>Hello&nbsp;javascripter!</div><p>See tests/test_core.js for more examples on usage. </p>\n", "important": true, "sig": "(name, properties)", "type": "function", "children": []}, {"short": "Application", "name": "Tea.Application", "text": "<p>Nice structured way to organize your app.  ready() is called when the page is ready, i.e. jQuery.ready. </p>\n<p>To setup the app, use .setup([properties]), where properties are extra properties to set on the object. </p>\n<p>Also note that any Tea.Application subclasses are immediately turned into singletons. </p>\n", "important": false, "sig": "", "type": "class", "children": []}, {"short": "Class", "name": "Tea.Class", "text": "<p>Extend Tea.Object by a new class.  This is synonymous with  Tea.Object.extend(name, properties). </p>\n", "important": false, "sig": "([name], properties)", "type": "function", "children": []}, {"short": "Container", "name": "Tea.Container", "text": "<p>An element that contains other elements. </p>\n<p>More comments. </p>\n", "requires": ["Tea.Element"], "important": false, "sig": "", "type": "class", "children": [{"short": "own", "name": "Tea.Container.own", "text": "<p>Owns the &lt;item&gt;, asserting that &lt;item.parent&gt; points to &lt;this&gt;. </p>\n", "important": false, "sig": "(item)", "type": "function", "children": []}]}, {"short": "Dialog", "name": "Tea.Dialog", "text": "<p>A Panel that displays itself over the ui to prompt the user. </p>\n", "requires": ["Tea.Panel"], "important": false, "sig": "", "type": "class", "children": []}, {"short": "Drag", "name": "Tea.Drag", "text": "<p>Dragging and dropping. </p>\n", "requires": ["Tea"], "important": false, "sig": "", "type": "class", "children": []}, {"short": "Element", "name": "Tea.Element", "text": "<p>Represents a basic ui element. Elements have sources, a jQuery expression that points to specific DOM elements. Elements have a skin, which builds the DOM element, and handle DOM element specific logic. Elements can have parents. </p>\n<p>options:     source:         A jQuery element that serves as the base for manipulating the object.  In the case          of a string or dom element, it is run through the jQuery ($) function. </p>\n", "requires": ["Tea"], "important": false, "sig": "", "type": "class", "children": []}, {"short": "Field", "name": "Tea.Field", "text": "<p>A field here is an element that holds a label, an input element, and error text. </p>\n<p>The value is normally merely a proxy to the input value. </p>\n", "requires": ["Tea.Input"], "important": false, "sig": "", "type": "class", "children": []}, {"short": "Input", "name": "Tea.Input", "text": "<p>An input element, which is to say anything that interacts with the user as a unit element, like a text input, or select. </p>\n<p>The value is normally merely a proxy to the input value. </p>\n", "requires": ["Tea.Container"], "important": false, "sig": "", "type": "class", "children": []}, {"short": "List", "name": "Tea.List", "text": "<p>A container that lists content as Tea.ListItem elements. </p>\n", "requires": ["Tea.Container"], "important": false, "sig": "", "type": "class", "children": []}, {"short": "Object", "name": "Tea.Object", "text": "<p>Base object that allows class/subclass behavior, events, and a regard for          \"options\". </p>\n", "important": false, "sig": "", "type": "class", "children": [{"short": "__init__", "name": "Tea.Object.__init__", "text": "<p>Initializes the instance, setting the options. </p>\n", "important": false, "sig": "(options)", "type": "function", "children": []}, {"short": "bind", "name": "Tea.Object.bind", "text": "<p>Binds an event for this instance to the given function which will be  called with the given args. </p>\n<p>event:     An event name to bind. </p>\n<p>handler:     The function to call when the event is triggered. </p>\n<p>args (optional):     A list of arguments to pass into when calling the handler. </p>\n", "important": false, "sig": "(event, handler, [args])", "type": "function", "children": []}, {"short": "hook", "name": "Tea.Object.hook", "text": "<p>Binds onto the target, but does so in a manner that allows this object to track its \"hooks\".  One can then unhook(target), or unhookAll() to release the bind.  This is beneficial from a memory standpoint, as hooks won't leak like a bind will. </p>\n<p>target:     The target to bind onto. </p>\n<p>event:     An event name to bind. </p>\n<p>handler:     The function to call when the event is triggered. </p>\n<p>args (optional):     A list of arguments to pass into when calling the handler. </p>\n", "important": false, "sig": "(target, event, handler, [args])", "type": "function", "children": []}, {"short": "init", "name": "Tea.Object.init", "text": "<p>This is not used by the internals of Tea, so that one can use it for final, user generated classes.  It is called after __init__. </p>\n", "important": false, "sig": "(options)", "type": "function", "children": []}, {"short": "toString", "name": "Tea.Object.toString", "text": "<p>Returns a string representation of the object. </p>\n", "important": false, "sig": "()", "type": "function", "children": []}, {"short": "trigger", "name": "Tea.Object.prototype.trigger", "text": "<p>event:         The event name to trigger. </p>\n<p>    args:         Arguments to pass onto the function.  These go after         any arguments set in the bind(). </p>\n", "important": false, "sig": "(name)", "type": "function", "children": []}, {"short": "unbind", "name": "Tea.Object.prototype.unbind", "text": "<p>Unbinds an events from this instance.  If a handler is given, only  events pointing to that handler are unbound.  Otherwise all handlers  for that event are unbound. </p>\n<p>event:     An event name to unbind. </p>\n<p>handler:     Only events pointing the given handler are unbound. </p>\n", "important": false, "sig": "(event, [handler])", "type": "function", "children": []}, {"short": "unhook", "name": "Tea.Object.unhook", "text": "<p>Unhooks all binds on target. </p>\n<p>target:     The target to release all binds from. </p>\n", "important": false, "sig": "(target)", "type": "function", "children": []}, {"short": "unhookAll", "name": "Tea.Object.unhookAll", "text": "<p>Unhooks all binds on all targets. </p>\n", "important": false, "sig": "()", "type": "function", "children": []}]}, {"short": "Panel", "name": "Tea.Panel", "text": "<p>A container that can may be closed, and may have a title bar, a top action bar, or a bottom action bar. </p>\n", "requires": ["Tea.Container"], "important": false, "sig": "", "type": "class", "children": []}, {"short": "Popup", "name": "Tea.Popup", "text": "<p>A container that \"pops up\".  You can show() and hide() it. </p>\n", "important": false, "sig": "", "type": "class", "extends": ["Tea.Container"], "requires": ["Tea.Container"], "children": []}, {"short": "Scrim", "name": "Tea.Scrim", "text": "<p>A translucent background that goes behind a dialog but over everything else.  It has the effect of fading everything else out. </p>\n", "important": false, "sig": "", "type": "class", "children": []}, {"short": "Stack", "name": "Tea.Stack", "text": "<p>A container that acts as a stack, you can push and pop onto it. </p>\n<p>    The default skin pushes elements onto it from the right to the left, so     that you only see the top few elements that can fit on the screen. </p>\n", "important": false, "sig": "", "type": "class", "extends": ["Tea.Container"], "requires": ["Tea.Container"], "children": [{"short": "pop", "name": "Tea.Stack.pop", "text": "<p>Pops the top item off the stack. </p>\n<p>If *item* is specified, it will pop that item and all after it. </p>\n", "important": false, "sig": "( [item] )", "type": "function", "children": []}, {"short": "push", "name": "Tea.Stack.push", "text": "<p>Pushes the *item* onto the stack. </p>\n<p>If *after* is specified, all items after it will be popped before pushing the *item*. </p>\n", "important": false, "sig": "(item, [after])", "type": "function", "children": []}]}, {"short": "Template", "name": "Tea.Template", "text": "<p>Naive template implementation.     NOTE: There is no escaping done here, only apply on trusted data. </p>\n<p>    Example:         var context = {must: 'will'};         var t = new Tea.Template('Bugs <img src=\"must\" alt=\"must\"> go.  They <img src=\"must\" alt=\"must\">.');         assertEqual(t.apply(context), 'Bugs will go.  They will.'); </p>\n", "requires": ["Tea"], "important": false, "sig": "", "type": "class", "children": [{"short": "__init__", "name": "Tea.Template.__init__", "text": "<p>Instantiate a template with the given source, and optionally options. </p>\n", "important": false, "sig": "(src, [options])", "type": "function", "children": []}, {"short": "apply", "name": "Tea.Template.apply", "text": "<p>Applies the template with the given context. </p>\n", "important": false, "sig": "(context)", "type": "function", "children": []}, {"short": "options", "name": "Tea.Template.options", "text": "<p>re:         The regular expression used, defaults to: /<img src=\"\\s*(.*?)\\s*\" alt=\"\\s*(.*?)\\s*\">/g, which         matches things like: something something {match} something.     missing_throws:         Throw an exception if a variable cannot be resolved, otherwise         it merely replaces the variable with an empty string ''.     html_encode:         Converts \"&amp;\", \"&lt;\", and \"&gt;\" to \"&amp;amp;\", \"&amp;lt;\", and \"&amp;gt;\", respectively. </p>\n", "important": false, "sig": "", "type": "class", "children": []}]}, {"short": "Testing", "name": "Tea.Testing", "text": "<p>A testing framework. </p>\n", "requires": ["Tea"], "important": false, "sig": "", "type": "module", "children": []}, {"short": "Tree", "name": "Tea.Tree", "text": "<p>A Tree item, each tree has a head and tail, the tail is a container,     the head is a button. </p>\n", "important": false, "sig": "", "type": "class", "extends": ["Tea.Container"], "requires": ["Tea.Container"], "children": []}, {"short": "Widget", "name": "Tea.Widget", "text": "<p>A few ui widgets, like buttons, and... well that's it so far. </p>\n", "requires": ["Tea.Element"], "important": false, "sig": "", "type": "module", "children": []}, {"short": "ajax", "name": "Tea.ajax", "text": "<p>Makes an ajax call to the given resource using jQuery.ajax.  Some options are automatically configured for you to make things easier. </p>\n<p>Tea.ajax will look up any Route with the name of the url you pass in.  The route's url is then replaced.  For instance if you had a route named 'document' that pointed to '/ajax/document/', you can use the options {url: 'document'}, which will then expand to: {url: '/ajax/document/'}. </p>\n<p>overriding:     Shortcut to merge these overriding-options onto options. </p>\n", "important": false, "sig": "(options, [overriding])", "type": "function", "children": []}, {"short": "deselect", "name": "Tea.deselect", "text": "<p>Quick function to do a global deselect of all text that can pop-up during dragging or the like. </p>\n", "important": false, "sig": "()", "type": "function", "children": []}, {"short": "evalJSON", "name": "Tea.evalJSON", "text": "<p>Evaluates a given piece of json source. </p>\n", "important": false, "sig": "(src)", "type": "function", "children": []}, {"short": "extend", "name": "Tea.extend", "text": "<p>Very much like jQuery.extend(receiver, donator), except that it will  combine functions to be able to use __super__(), also it will merge Tea.Options objects. </p>\n", "important": false, "sig": "(receiver, donator)", "type": "function", "children": []}, {"short": "getClass", "name": "Tea.getClass", "text": "<p>Returns a class with the given name. </p>\n", "important": false, "sig": "(name)", "type": "function", "children": []}, {"short": "isInstance", "name": "Tea.isInstance", "text": "<p>If instance is an instance of cls, then we return true, otherwise false. </p>\n", "important": false, "sig": "(instance, cls)", "type": "function", "children": []}, {"short": "latent", "name": "Tea.latent", "text": "<p>Calls the given function <tt>func</tt> after the given <tt>milliseconds</tt> with a <tt>this</tt> of <tt>context</tt>. </p>\n<p>The function returned is a wrapper function.  When it is called, it waits  for the specified <tt>milliseconds</tt> before actually being run.  Also, if it is waiting to run, and is called again, it will refresh its timer. This is great for things like auto-complete, where you want to cancel and refresh the timer every time a key is hit </p>\n<p>You can easily bind a latent to an event, the following code will run  the method \"onKeyup\" on \"this\" 300 milliseconds after the last keyup event  of a series: </p>\n<p><tt>$(window).keyup( Tea.latent(300, this.onKeyup, this) )</tt> </p>\n<p>The function returned also provides a few extra methods on the function, itself: </p>\n<p><tt>.cancel()</tt> - Cancels the timer. </p>\n<p><tt>.refresh([milliseconds])</tt> - Refreshes the timer, and optionally resets the <tt>milliseconds</tt>. </p>\n<p>Example: </p>\n<div class='code'>function&nbsp;hello()&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;this.log(\"Hello&nbsp;World!\");<br/>}<br/><br/>hello&nbsp;=&nbsp;latent(hello,&nbsp;console,&nbsp;1000);<br/>hello();<br/>hello();<br/>hello();<br/><br/>//&nbsp;After&nbsp;1&nbsp;second:&nbsp;\"Hello&nbsp;World!\"<br/><br/>hello();<br/>hello.cancel();<br/><br/>//&nbsp;Nothing...<br/><br/>hello.refresh(1000);<br/><br/>//&nbsp;After&nbsp;1&nbsp;second:&nbsp;\"Hello&nbsp;World!\"<br/><br/>hello();<br/><br/>//&nbsp;After&nbsp;1&nbsp;second:&nbsp;\"Hello&nbsp;World!\"</div>", "important": false, "sig": "(milliseconds, func, context)", "type": "function", "children": []}, {"short": "manifest", "name": "Tea.manifest", "text": "", "important": false, "sig": "([clsName], obj)", "type": "function", "children": []}, {"short": "method", "name": "Tea.method", "text": "<p>Creates a callback that, when run, calls the given function with the given context as 'this'. It is often used for binding callbacks for events and the like. </p>\n<p>Example: </p>\n<div class='code'>var&nbsp;panel&nbsp;=&nbsp;new&nbsp;Tea.Panel({<br/>&nbsp;&nbsp;&nbsp;&nbsp;onKeyup&nbsp;:&nbsp;function()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log(\"Recieved&nbsp;keypress.\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>});<br/><br/>$(window).keyup(&nbsp;Tea.method(panel.onKeyup,&nbsp;panel)&nbsp;);</div>", "important": false, "sig": "(context, function)", "type": "function", "children": []}, {"short": "overrideMethod", "name": "Tea.overrideMethod", "text": "<p>Creates a callback that when run, provides a <tt>__super__</tt> on *this* which points to  <tt>super_function</tt>, and then runs <tt>func</tt>.  A great way to do inheritance. </p>\n", "important": false, "sig": "(super_function, function)", "type": "function", "children": []}, {"short": "quoteString", "name": "Tea.quoteString", "text": "<p>Returns a string-repr of a string, escaping quotes intelligently.   Mostly a support function for toJSON. </p>\n<p>Examples: </p>\n<div class='code'>&gt;&gt;&gt;&nbsp;jQuery.quoteString(\"apple\")<br/>\"apple\"<br/><br/>&gt;&gt;&gt;&nbsp;jQuery.quoteString('\"Where&nbsp;are&nbsp;we&nbsp;going?\",&nbsp;she&nbsp;asked.')<br/>\"\\\"Where&nbsp;are&nbsp;we&nbsp;going?\\\",&nbsp;she&nbsp;asked.\"</div>", "important": false, "sig": "(string)", "type": "function", "children": []}, {"short": "registerClass", "name": "Tea.registerClass", "text": "<p>Registeres a class with Tea, so that it can be found by name. </p>\n<p>name:     Name of the class. </p>\n<p>type:     The class. </p>\n", "important": false, "sig": "(name, type)", "type": "function", "children": []}, {"short": "require", "name": "Tea.require", "text": "<p>Imports the given arguments by appending &lt;script&gt; or &lt;style&gt; tags to the head. Note: Perhaps it is too obvious: but importing is done relative to the page we're on. Note: The required script is loaded sometime AFTER the requiring script, so you can't use       the provided namespace (functions and variables) right away. </p>\n<p>arguments:     Strings of urls to the given resource.  If the string ends with .css, it is added with     a &lt;style&gt; tag; if it's a .js, it is added with a &lt;script&gt; tag. </p>\n", "important": false, "sig": "(...)", "type": "function", "children": []}, {"short": "secureEvalJSON", "name": "Tea.secureEvalJSON", "text": "<p>Evals JSON in a way that is *more* secure. </p>\n", "important": false, "sig": "(src)", "type": "function", "children": []}, {"short": "toJSON", "name": "Tea.toJSON", "text": "<p>Converts the given argument into a JSON respresentation. </p>\n<p>If an object has a \"toJSON\" function, that will be used to get the representation. Non-integer/string keys are skipped in the object, as are keys that point to a function. </p>\n<p>json-serializble:     The *thing* to be converted. </p>\n", "important": false, "sig": "( json-serializble )", "type": "function", "children": []}]}]